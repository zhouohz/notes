## Node 实现 Apache 的功能

在 Apache 中有一个默认的 www 目录，所有存放在 www 目录中的资源都可以通过更改ip和端口后的 url 地址访问，即 `localhost:3000/相对路径/资源名` 基于www目录的相对路径。

目前只能通过node实现根据不同的预设url标识，响应不同的信息，每一个url都需要提前预设，新增了资源时，又得在if判断中添加新的url判断，读取对应的资源响应给客户端。这样做可太蠢了。而且可移植性很差，只要www目录的位置发生改变，所有的读取文件路径都得改，当然可以做一个拼接处理，把前面公共的到www的路径保存为一个变量，资源移动后，更改这个变量就好了

提到了多次 if else 就讲一个小技巧，直接 if 写出错时的情况，然后return掉，接着就可以写正常的功能代码了。这样做可以不用写 else 嵌套。代码更简洁清晰。

所谓的从服务器请求资源就是请求的资源里的数据，因为资源本身在计算机中就是一堆数据，二进制什么的。所以，请求一个页面也好，请求一张图片也好，本质上和直接发送一个字符串没有任何区别

这里有一个处理方法，就是客户端请求的网络地址后的url是和服务器上的资源名一样的，那么，在读取文件的时候，可以把文件名替换为 resquest.url ，这样一次判断就可以统一处理所有的资源请求了。

初步代码

```javascript
let http = require('http')
let fs = require('fs')

let server = http.createServer()

// 资源文件夹的目录为 c:/www/

let wwwDir = 'c:/www'
let filePath = '/index.html'

server.on('request', function (request, response) {

  if (request.url !== '/') {
    filePath = request.url
  }

  fs.readFile(wwwDir + filePath, function (error, data) {
    if (error) {
      return response.end('404 not found')
    }
    response.end(data)
  })
  
})

server.listen(3000, function () {
  console.log('server is running...')
  
})
```

到此实现了随意添加资源以及资源移动时统一修改路径的功能。

apache还有一个功能是 如果www里面没有index.html，则在页面中显示全部资源的目录结构，可以让用户可视化的选择想要打开的资源。这个目录结构对于浏览器来说其实就是一个页面，那些文件夹图标就是图片，可以打开的目录是链接

1. 首先可以将文件夹拖到浏览器中，也会显示目录列表，复制其HTML结构和CSS样式作为模板使用
2. 现在就可以在用户请求的时候直接读取这个模板页面发送给客户端，但是里面的文件列表内容是固定的。
3. 所以，现在要做的就是在node中将www的目录列表动态添加到模板中，然后响应给客户端。
4. 而这又有一个问题，就是如何读取一个目录中的文件列表。其实，fs核心模块提供了一个API可以实现，返回值是列表名字符串组成的数组。
	`fs.readdir('path', function(error, lists) { })`
5. 现在我们可以拿到文件列表项以及模板了。其实可以直接使用字符串的 replace() 方法替换，遍历 readdir 方法的到的数组，当然模板中固定的数据需要改成一个约定的标识，如 `*` 或者 `#` 之类的，便于找到需要替换的位置
	`data.replace('*', item)`
	这个方法默认只会替换第一个匹配的字符，遍历到第二项的时候正好也是模板中的第二个标识位，所以标识符可以统一设置为一样的
6. 也可以遍历文件列表数组，复制一个 tr 的html字符串过来，替换里面的内容，遍历了几项就拼接了几个 tr 。然后将这个拼好的内容用5的方法替换到读取过来的html页面中。其实就跟以前学 JQ 时的动态生成评论一样，页面中只有一个ul标签，由js获取文本框中的信息，然后拼接一个li标签出来，prepend到ul中
7. 关于字符串的拼接，补充一个知识，就是 ES6 的模板字符串语法，它就跟pre标签一样，会保留写的时候的格式，而且支持换行，拼接也更方便，在 `${}` 中写上变量，放到想要拼接的位置即可，以前是在 `'+ +'` 中添加
8. 以上是一个很好的思路，但缺点也很明显，就是过于繁琐，JS中有太多的html字符串了。这时就需要用到模板引擎了，它不是一个前端专属的技术，而且恰恰相反，这是从后端诞生的。