## 什么是路由

通过互联网把信息从源地址传输到目的地址的活动

路由表的本质是一个映射表

### 后端路由

由后端决定 url 和页面之间的对应关系. 服务器直接读取模板页面, 再去数据库中读取数据, 渲染完成后发送给客户端

后端渲染的内容可以在网页源码中看到. 利于 SEO 优化

后端任务繁重, 前端人员没什么价值

### 前后端分离

前后端分离后, 后端只负责提供数据接口

由前端人员编写 js 代码, 通过 Ajax 去请求数据, 然后操作 DOM, 将数据渲染到页面中

### 前端路由

在前后端分离之后, 又进入了下一个阶段, 就是单页面应用阶段. 由前端维护一个路由表

整个网页只有一个 html 页面. 

根据不同的 hash 值渲染不同的页面内容, 其实就是 vue 组件

打包的时候会把所有的 vue 文件打包到一个 JS 文件中, hash 值变化时, 就 JS 就执行对应的代码, 渲染对应的组件

前端路由就是 hash 和组件之间的映射

### Hash

默认修改 url 页面会发生刷新, 重新发送请求, 但是通过 `location.hash` 改变 hash 值就不会刷新

在 H5 中新增的方式: `history.pushState({}, '', 'home')` , 页面的 url 后面会添加 /home, 但是不会刷新.
  - 原理: 是将 home 进行入栈, 还可以继续 push 其他的路由, url 后面显示的始终是栈顶的路由标识
  - 而且会保存在 history 中, 页面回退的时候, 就出栈, url 上显示第二个路由标识
还有一个是 `history.replaceState({}, '', 'home')` 效果一样, 只不过不是维护一个栈, 不会生成历史记录, 是替换之前的路由

history.go(num) 控制历史页面的跳转, num = -1 相当于 history.back(); num = 1 相当于 history.forward(). 只能配合 history.pushState() 使用, 生成历史记录

以后在配置路由时, 默认是 hash 模式, 也可以选择 history 模式